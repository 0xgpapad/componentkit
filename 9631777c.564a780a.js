(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{184:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return l}));var i=t(2),o=t(11),a=(t(0),t(203)),r={title:"Legacy APIs"},s={id:"animations-legacy-apis",title:"Legacy APIs",description:"If you have some previous ComponentKit experience you probably encountered other animation-related APIs in CK such as animationsOnInitialMount or animationsOnFinalUnmount. Currently, we are slowly transitioning away from those APIs since they encourage creating more subclasses (which is bad for the binary size) and at the same time limit component reusability.",source:"@site/docs/animations-legacy-apis.md",permalink:"/docs/animations-legacy-apis",sidebar:"docs",previous:{title:"Change Animations",permalink:"/docs/animations-change"},next:{title:"Overview",permalink:"/docs/datasource-overview"}},c=[],u={rightToc:c};function l(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(i.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"If you have some previous ComponentKit experience you probably encountered other animation-related APIs in CK such as ",Object(a.b)("inlineCode",{parentName:"p"},"animationsOnInitialMount")," or ",Object(a.b)("inlineCode",{parentName:"p"},"animationsOnFinalUnmount"),". Currently, we are slowly transitioning away from those APIs since they encourage creating more subclasses (which is bad for the binary size) and at the same time limit component reusability."),Object(a.b)("p",null,"Indeed, if you use one of those methods, your component will ",Object(a.b)("em",{parentName:"p"},"always"),' have the same initial or final animation regardless of context it\'s being used in. While this may be the behaviour you are looking for, usually there are better ways to achieve the same effect, such as described in the section "Initial / Final Animations" above. In general, you should turn to wrapping animated components in ',Object(a.b)("inlineCode",{parentName:"p"},"CKAnimationComponent")," first, before using ",Object(a.b)("inlineCode",{parentName:"p"},"animationsOnInitialMount")," or ",Object(a.b)("inlineCode",{parentName:"p"},"animationsOnFinalUnmount"),". If you actually need to have the same animations for the same component in multiple places, you should consider factoring wrapping this component in ",Object(a.b)("inlineCode",{parentName:"p"},"CKAnimationComponent")," to a separate function and using this function instead."),Object(a.b)("p",null,"Another API that is somewhat discouraged to use is providing the ",Object(a.b)("inlineCode",{parentName:"p"},"CKComponentAnimationHooks")," directly. There are some use cases that do require using that API, usually, integrations with other animation systems like POP or UIKit animations, and until fairly recently, final animation was one of such use cases too. Animation hooks should almost never be your first choice when animating your components, and we are working on reducing the number of cases when they are still needed by bringing the relevant functionality inside the framework."))}l.isMDXComponent=!0},203:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return b}));var i=t(0),o=t.n(i);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=o.a.createContext({}),l=function(e){var n=o.a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):s({},n,{},e)),t},p=function(e){var n=l(e.components);return o.a.createElement(u.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},y=Object(i.forwardRef)((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,r=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=l(t),y=i,b=p["".concat(r,".").concat(y)]||p[y]||m[y]||a;return t?o.a.createElement(b,s({ref:n},u,{components:t})):o.a.createElement(b,s({ref:n},u))}));function b(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,r=new Array(a);r[0]=y;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var u=2;u<a;u++)r[u]=t[u];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,t)}y.displayName="MDXCreateElement"}}]);