(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{167:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return m}));var o=t(2),i=t(11),a=(t(0),t(201)),r=t(203),c={title:"Change Animations"},s={id:"animations-change",title:"Change Animations",description:"To animate a change in a component, two conditions must be met:",source:"@site/docs/animations-change.md",permalink:"/docs/animations-change",sidebar:"docs",previous:{title:"Initial / Final Animations",permalink:"/docs/animations-initial-and-final"},next:{title:"Legacy APIs",permalink:"/docs/animations-legacy-apis"}},l=[{value:"Conditional Animations",id:"conditional-animations",children:[]}],p={rightToc:l};function m(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},p,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"To animate a change in a component, two conditions must be met:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"it needs to have a view or eventually render to a view")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"it needs to declare a scope so the infra is able to find the same logical component in both previous and current tree"))),Object(a.b)("p",null,"The actual animation should be constructed and returned in the ",Object(a.b)("inlineCode",{parentName:"p"},"animationsFromPreviousComponent:")," method in the form of a ",Object(a.b)("inlineCode",{parentName:"p"},"CKComponentAnimation")," instance. In the vast majority of cases, ",Object(a.b)("inlineCode",{parentName:"p"},"CKComponentAnimation")," is created from a component / animation pair."),Object(a.b)("p",null,"Let's see how this all applies in practice. Consider a component that changes it's background colour depending on one of its props:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),"+ (instancetype)newWithActive:(BOOL)isActive\n{\n  CKComponentScope scope(self);\n\n  return\n  [super\n   newWithView:{\n     [UIView class],\n     {{@selector(setBackgroundColor:), isActive ? UIColor.green : UIColor.gray}}\n   }\n   size:{}];\n}\n")),Object(a.b)("p",null,"Note, that the background colour is set as a part of the view configuration. Now, to change the background colour in an animated fashion, we need to provide an implementation for ",Object(a.b)("inlineCode",{parentName:"p"},"animationFromPreviousComponent:"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),"- (std::vector<CKComponentAnimation>)animationsFromPreviousComponent:(CKComponent *)previousComponent\n{\n  return {\n    {self, CK::Animation::backgroundColor()}\n  };\n}\n")),Object(a.b)("p",null,"and that's pretty much it. Note that we didn't have to specify the ",Object(a.b)("inlineCode",{parentName:"p"},"from")," and ",Object(a.b)("inlineCode",{parentName:"p"},"to")," animation values at all, since both are inferred from the view configuration."),Object(a.b)("video",{autoPlay:"true",className:"video",loop:!0},Object(a.b)("source",{type:"video/mp4",src:Object(r.a)("assets/animations-example-4.mp4")}),Object(a.b)("p",null,"Your browser does not support the video element.")),Object(a.b)("p",null,"Another (somewhat obvious) observation here is that, if you want to animate a change in a child component, not ",Object(a.b)("inlineCode",{parentName:"p"},"self"),", you need to store a reference to the animated component in an ivar on the parent component. Here's an example:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),"@implementation Example {\n  CKComponent *_greenBox;\n}\n\n+ (instancetype)newWithTrailing:(BOOL)isTrailing\n{\n  auto const greenBox =\n  [CKComponent\n    newWithView:{\n      [UIView class],\n      {{@selector(setBackgroundColor:), UIColor.greenColor}}\n    }\n    size:...];\n  auto const c =\n  [super\n    newWithComponent:\n    [CKFlexboxComponent\n      newWithView:...\n      size:{}\n      style:{\n        .direction = CKFlexboxDirectionRow,\n        .justifyContent = isTrailing ? CKFlexboxJustifyContentEnd : CKFlexboxJustifyContentStart\n      }\n      children:{\n        {greenBox}\n      }]];\n  c->_greenBox = greenBox;\n  return c;\n}\n")),Object(a.b)("p",null,"This component lays out it's only child component (a green box) either in a leading or in a trailing horizontal position depending on the ",Object(a.b)("inlineCode",{parentName:"p"},"isTrailing")," prop. In order to animate this change in the position of the green box we also need ",Object(a.b)("inlineCode",{parentName:"p"},"animationsFromPreviousComponent:")," implementation:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),"- (std::vector<CKComponentAnimation>)animationsFromPreviousComponent:(CKComponent *)previousComponent\n{\n  return {\n    {_greenBox, CK::Animation::position().easeOut()}\n  };\n}\n")),Object(a.b)("video",{autoPlay:"true",className:"video",loop:!0},Object(a.b)("source",{type:"video/mp4",src:Object(r.a)("assets/animations-example-5.mp4")}),Object(a.b)("p",null,"Your browser does not support the video element.")),Object(a.b)("p",null,"Here, we used the stored reference to the child component to initialise the returned instance of ",Object(a.b)("inlineCode",{parentName:"p"},"CKComponentAnimation"),". Most importantly, we didn't need to explicitly specify ",Object(a.b)("inlineCode",{parentName:"p"},"from")," and ",Object(a.b)("inlineCode",{parentName:"p"},"to")," values again because both will be inferred again, this time not from the view configuration specifically but from the ",Object(a.b)("inlineCode",{parentName:"p"},"bounds")," and ",Object(a.b)("inlineCode",{parentName:"p"},"center")," properties that are set at mount time."),Object(a.b)("h3",{id:"conditional-animations"},"Conditional Animations"),Object(a.b)("p",null,"What if we put both these examples together and allow for changes in both background colour and position by passing both flags in props:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),"@implementation Example {\n  CKComponent *_box;\n}\n\n+ (instancetype)newWithActive:(BOOL)isActive trailing:(BOOL)isTrailing\n{\n  auto const box =\n  [CKComponent\n    newWithView:{\n      [UIView class],\n      {{@selector(setBackgroundColor:), isActive ? UIColor.greenColor : UIColor.grayColor}}\n    }\n    size:...];\n  auto const c =\n  [super\n    newWithComponent:\n    [CKFlexboxComponent\n      newWithView:...\n      size:{}\n      style:{\n        .direction = CKFlexboxDirectionRow,\n        .justifyContent = isTrailing ? CKFlexboxJustifyContentEnd : CKFlexboxJustifyContentStart\n      }\n      children:{\n        {box}\n      }]];\n  c->_box = box;\n  return c;\n}\n")),Object(a.b)("p",null,"You can combine animations for both properties using ",Object(a.b)("inlineCode",{parentName:"p"},"parallel()")," combinator like this:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),"- (std::vector<CKComponentAnimation>)animationsFromPreviousComponent:(CKComponent *)previousComponent\n{\n  return {\n    {_greenBox, CK::Animation::parallel(CK::Animation::position().easeOut(), CK::Animation::backgroundColor())}\n  };\n}\n")),Object(a.b)("video",{autoPlay:"true",className:"video",loop:!0},Object(a.b)("source",{type:"video/mp4",src:Object(r.a)("assets/animations-example-6.mp4")}),Object(a.b)("p",null,"Your browser does not support the video element.")),Object(a.b)("p",null,"However, if only one of the flags (",Object(a.b)("inlineCode",{parentName:"p"},"isActive")," or ",Object(a.b)("inlineCode",{parentName:"p"},"isTrailing"),") changed as a result of a state update, there is no need to animate the other property. It won't have any visual effect in this case but still puts additional load on the infra. The component tree may also be regenerated for other reasons, such as state updates in other components, so the animations should be conditional. This leads us to a conclusion that, in most cases, there has to be something in the state or props that will tell you if animation is needed. The relevant information needs to be saved as an ivar and used in ",Object(a.b)("inlineCode",{parentName:"p"},"animationsFromPreviousComponent:")," like this:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),"@implementation Example {\n  CKComponent *_box;\n  BOOL _isActive;\n  BOOL _isTrailing;\n}\n\n+ (instancetype)newWithActive:(BOOL)isActive trailing:(BOOL)isTrailing\n{\n  ...\n  c->_box = box;\n  c->_isActive = isActive;\n  c->_isTrailing = isTrailing;\n  return c;\n}\n\n- (std::vector<CKComponentAnimation>)animationsFromPreviousComponent:(CKComponent *)previousComponent\n{\n  auto const prev = CK::objCForceCast<Example>(previousComponent);\n\n  auto animations = std::vector<CKComponentAnimation>{};\n  if (prev->_isActive != _isActive) {\n    animations.push_back({_box, CK::Animation::backgroundColor()});\n  }\n  if (prev->_isTrailing != isTrailing) {\n    animations.push_back({_box, CK::Animation::position().easeOut()});\n  }\n  return animations;\n}\n\n")),Object(a.b)("video",{autoPlay:"true",className:"video",loop:!0},Object(a.b)("source",{type:"video/mp4",src:Object(r.a)("assets/animations-example-7.mp4")}),Object(a.b)("p",null,"Your browser does not support the video element.")),Object(a.b)("div",{class:"note"},Object(a.b)("p",null,"In order to animate a change you just need to set the proper values in the view configuration or alter the layout, and return one or more animations for the corresponding properties from ",Object(a.b)("inlineCode",{parentName:"p"},"animationsFromPreviousComponent:")," without specifying initial and final values. Make sure to return only animations for properties that have actually changed.")))}m.isMDXComponent=!0},201:function(e,n,t){"use strict";t.d(n,"a",(function(){return m})),t.d(n,"b",(function(){return d}));var o=t(0),i=t.n(o);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=i.a.createContext({}),p=function(e){var n=i.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c({},n,{},e)),t},m=function(e){var n=p(e.components);return i.a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},b=Object(o.forwardRef)((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,r=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=p(t),b=o,d=m["".concat(r,".").concat(b)]||m[b]||u[b]||a;return t?i.a.createElement(d,c({ref:n},l,{components:t})):i.a.createElement(d,c({ref:n},l))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,r=new Array(a);r[0]=b;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,r[1]=c;for(var l=2;l<a;l++)r[l]=t[l];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},202:function(e,n,t){"use strict";var o=t(0),i=t(59);n.a=function(){return Object(o.useContext)(i.a)}},203:function(e,n,t){"use strict";t.d(n,"a",(function(){return i}));t(204);var o=t(202);function i(e){var n=(Object(o.a)().siteConfig||{}).baseUrl,t=void 0===n?"/":n;if(!e)return e;return/^(https?:|\/\/)/.test(e)?e:e.startsWith("/")?t+e.slice(1):t+e}},204:function(e,n,t){"use strict";var o=t(8),i=t(10),a=t(205),r="".startsWith;o(o.P+o.F*t(206)("startsWith"),"String",{startsWith:function(e){var n=a(this,e,"startsWith"),t=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),o=String(e);return r?r.call(n,o,t):n.slice(t,t+o.length)===o}})},205:function(e,n,t){var o=t(86),i=t(30);e.exports=function(e,n,t){if(o(n))throw TypeError("String#"+t+" doesn't accept regex!");return String(i(e))}},206:function(e,n,t){var o=t(3)("match");e.exports=function(e){var n=/./;try{"/./"[e](n)}catch(t){try{return n[o]=!1,!"/./"[e](n)}catch(i){}}return!0}}}]);