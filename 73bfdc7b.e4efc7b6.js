(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{174:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return d}));var o=n(2),a=n(11),i=(n(0),n(202)),r={title:"Gotchas"},c={id:"datasource-gotchas",title:"Gotchas",description:"Don't forget the initial section",source:"@site/docs/datasource-gotchas.md",permalink:"/docs/datasource-gotchas",sidebar:"docs",previous:{title:"Changeset API",permalink:"/docs/datasource-changeset-api"},next:{title:"Dive Deeper",permalink:"/docs/datasource-dive-deeper"}},s=[{value:"Don&#39;t forget the initial section",id:"dont-forget-the-initial-section",children:[]},{value:"Lifecycle",id:"lifecycle",children:[]},{value:"The datasource involves asynchronous operations",id:"the-datasource-involves-asynchronous-operations",children:[]}],l={rightToc:s};function d(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"dont-forget-the-initial-section"},"Don't forget the initial section"),Object(i.b)("p",null,"A datasource will initially be totally empty (no items and no sections). Inserting items in section 0 before inserting section 0 will cause an exception to be raised."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),'CKComponentCollectionViewDataSource datasource = [[CKComponentCollectionViewDataSource alloc] ...];\nCKArrayControllerInputItems items;\nCKArrayControllerSections sections;\nsections.insert(0);\nitems.insert({0, 0}, @"Hello");\n[datasource enqueueChangeset:{sections, items}];\n')),Object(i.b)("div",{class:"note"},Object(i.b)("p",null,"Why not have one section by default? Because implicit/default behaviors can be confusing.\nIf that behavior was implemented as a default but not documented, it would be very confusing when inserting a section at index 0 on a newly created datasource will actually cause it to have two sections (we already have the one created by default).\nObviously documentation would make things better but it's easy to miss a piece of documentation...")),Object(i.b)("h2",{id:"lifecycle"},"Lifecycle"),Object(i.b)("p",null,"The lifecycle of the datasource should match the lifecycle of the collection view or table view it is used with. You might otherwise end up with the content of your list view being out of sync with the internal state of the datasource and this will cause a crash eventually."),Object(i.b)("h2",{id:"the-datasource-involves-asynchronous-operations"},"The datasource involves asynchronous operations"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Each changeset is computed asynchronously")," by ",Object(i.b)("inlineCode",{parentName:"p"},"CKComponentDatasource"),", therefore the corresponding changes are not reflected immediately on the corresponding ",Object(i.b)("inlineCode",{parentName:"p"},"UITableView")," or ",Object(i.b)("inlineCode",{parentName:"p"},"UICollectionView")," and it is important to be careful about sources of data being out of sync."),Object(i.b)("h4",{id:"always-ask-the-datasource-for-the-model-corresponding-to-an-index-path"},"Always ask the datasource for the model corresponding to an index path"),Object(i.b)("p",null,"The datasource maintains an internal data structure which is the only source of truth for the corresponding ",Object(i.b)("inlineCode",{parentName:"p"},"UICollectionView")," or ",Object(i.b)("inlineCode",{parentName:"p"},"UITableView"),". For this reason you should query the datasource to get information associated with a certain indexPath. Any other source of data may be out of sync with the current state of the list view."),Object(i.b)("p",null,"For instance to access the model associated to a certain index path using a ",Object(i.b)("inlineCode",{parentName:"p"},"CKCollectionViewDataSource")," you can use:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),"[datasource modelForItemAtIndexPath:indexPath];\n")),Object(i.b)("p",null,"Now let's look at what could go wrong if we query another source of data."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),"@implementation MyAwesomeController {\n    CKComponentCollectionViewDataSource *_datasource;\n    NSMutableArray *_listOfModels;\n}\n\n- (void)insertAtHead:(id)model {\n// We first add the new model (B) at the beginning of _listOfModels which already contained (A)\n    // [A] -> [B, A]\n  [_listOfModels insertObject:model atIndex:0];\n  CKArrayControllerInputItems items;\n  items.insert({0, 0});\n  // Enqueue the changeset asynchronously in the datasource\n  [_datasource enqueueChangeset:{{}, items}];\n}\n\n- (void)didSelectitemAtIndexPath:(NSIndexPath *)indexPath {\n// At the same time the user taps on the cell that represents A, which is still located at the indexPath (0,0)\n// as the changeset has not finished computing yet.\n// Ouch we actually get B, list of models and the collection view are out of sync\n[_listOfModels objectAtIndex:indexPath.row];\n// [_datasource modelForItemAtIndexPath:indexPath] would have properly returned A\n}\n")),Object(i.b)("h4",{id:"dont-ask-the-the-list-view-for-the-position-of-the-next-insertion"},"Don't ask the the list view for the position of the next insertion"),Object(i.b)("p",null,"The datasource gives you the current state of what is displayed on the screen, but it doesn't include what is potentially currently being computed in the background. To get this information you need to maintain state that is updated at the same time as a changeset is enqueued."),Object(i.b)("p",null,"Let's look at this buggy code that uses the datasource to compute the insertion index."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec-redhighlight"}),"@implementation MyAwesomeController {\n    CKComponentCollectionViewDataSource *_datasource;\n    NSMutableArray *_listOfModels;\n}\n\n- (void)insertAtTail:(id)model {\n// We first add the new model (C) at the end of _listOfModels which already contains (A) et (B)\n    // [A, B] -> [A, B, C]\n  [_listOfModels addObject:model];\n  CKArrayControllerInputItems items;\n  // Only A is in the tableView, the components for B are still computed in the background\n  // so numberOfItemsInSection returns 1, C will be inserted at index 1 and we will end up\n  // with a list view displaying [A, C, B]\n  Items.insert({0, _datasource.collectionView numberOfItemsInSection});\n  // Enqueue the changeset asynchronously in the datasource\n  [_datasource enqueueChangeset:{{}, items}];\n}\n")),Object(i.b)("p",null,"In ",Object(i.b)("inlineCode",{parentName:"p"},"-insertAtTail")," we should check ",Object(i.b)("inlineCode",{parentName:"p"},"_listOfModels")," instead to compute the insertion index."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-objectivec"}),"- (void)insertAtTail:(id)model {\n// We first add the new model (C) at the end of _listOfModels which already contains (A) et (B)\n    // [A, B] -> [A, B, C]\n  [_listOfModels addObject:model];\n  CKArrayControllerInputItems items;\n  // We properly insert C at index 2\n  Items.insert({0, [_listOfModels count] ? [_listOfModels count] -1 : 0});\n  // Enqueue the changeset asynchronously in the datasource\n  [_datasource enqueueChangeset:{{}, items}];\n}\n")))}d.isMDXComponent=!0},202:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var o=n(0),a=n.n(o);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),d=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c({},t,{},e)),n},u=function(e){var t=d(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},p=Object(o.forwardRef)((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=d(n),p=o,b=u["".concat(r,".").concat(p)]||u[p]||h[p]||i;return n?a.a.createElement(b,c({ref:t},l,{components:n})):a.a.createElement(b,c({ref:t},l))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=p;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,r[1]=c;for(var l=2;l<i;l++)r[l]=n[l];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);